---
description: "TDDベースの実装を実行し、tasks.mdのチェックリストを段階的に完了させる"
allowed-tools: Read, Write, Edit, Glob, Grep, Bash, AskUserQuestion
---

# Implement - TDDベース実装実行

`tasks.md` のチェックリストに従って、TDD（テスト駆動開発）ベースで実装を実行します。

## 前提条件

**実行前に必ず `sdd-workflow-ja:sdd-workflow` エージェントの内容を読み込み、AI-SDDの原則を理解してください。**

このコマンドはsdd-workflowエージェントの原則に従って実装を行います。

### ディレクトリパスの解決

**環境変数 `SDD_*` を使用してディレクトリパスを解決します。**

| 環境変数                     | デフォルト値               | 説明              |
|:-------------------------|:---------------------|:----------------|
| `SDD_ROOT`               | `.sdd`               | ルートディレクトリ       |
| `SDD_REQUIREMENT_PATH`   | `.sdd/requirement`   | PRD/要求仕様書ディレクトリ |
| `SDD_SPECIFICATION_PATH` | `.sdd/specification` | 仕様書・設計書ディレクトリ   |
| `SDD_TASK_PATH`          | `.sdd/task`          | タスクログディレクトリ     |

**パス解決の優先順位:**

1. 環境変数 `SDD_*` が設定されている場合はそれを使用
2. 環境変数がない場合は `.sdd-config.json` を確認
3. どちらもない場合はデフォルト値を使用

以下のドキュメントでは、デフォルト値を使用して説明しますが、環境変数または設定ファイルが存在する場合はカスタム値に置き換えてください。

### 必須前提条件

実行前に以下が存在することを確認してください:

| 前提条件      | 確認方法                                       | 生成コマンド                  |
|:----------|:-------------------------------------------|:------------------------|
| **タスク分解** | `.sdd/task/{チケット番号}/tasks.md` が存在する        | `/task_breakdown {機能名}` |
| **技術設計書** | `.sdd/specification/{機能名}_design.md` が存在する | `/generate_spec {機能名}`  |
| **抽象仕様書** | `.sdd/specification/{機能名}_spec.md` が存在する   | `/generate_spec {機能名}`  |

※ 階層構造の場合: `[{path}/]` を付加（例: `auth/user-login_spec.md`）。親機能の場合は `index_spec.md`

## 入力

$ARGUMENTS

### 入力フォーマット

```
/implement {機能名} {チケット番号}
/implement {機能名}  # 機能名をチケットディレクトリとして使用
```

### 入力例

```
/implement user-auth TICKET-123
/implement task-management FEAT-456
/implement auth/user-login TICKET-789  # 階層構造の場合
```

## TDD実装フロー

### 5つのフェーズ

実装は以下の5つのフェーズで段階的に実行されます：

| Phase | フェーズ名           | 目的                        | TDDアプローチ        |
|:------|:----------------|:--------------------------|:----------------|
| **1** | Setup（基盤）       | ディレクトリ構成、型定義              | テスト環境のセットアップ    |
| **2** | Tests（テスト先行）    | テストケース作成（Red）             | 失敗するテストを先に書く    |
| **3** | Core（コア実装）      | 主要機能の実装（Green）            | テストが通るように実装     |
| **4** | Integration（統合） | モジュール間連携（Green）           | 統合テストを先に書いてから実装 |
| **5** | Polish（仕上げ）     | リファクタリング、ドキュメント（Refactor） | テストを維持しながらコード改善 |

### フェーズごとの実行ルール

#### Phase 1: Setup

```
1. ディレクトリ構成を作成
2. 型定義ファイルを作成
3. 基本的なインターフェースを定義
4. テスト環境をセットアップ
```

**完了条件**: すべての基盤ファイルが作成され、テストが実行可能な状態

#### Phase 2: Tests

```
1. tasks.md のテストタスクを確認
2. 各機能に対応する失敗するテストを作成
3. テストを実行して Red（失敗）を確認
4. tasks.md にチェック [x] を入れる
```

**完了条件**: すべてのテストケースが作成され、期待通りに失敗している

#### Phase 3: Core

```
1. Phase 2 で作成したテストに対応する実装を行う
2. テストが Green（成功）になるように実装
3. 最小限の実装で済ませる（過剰な実装を避ける）
4. tasks.md にチェック [x] を入れる
```

**完了条件**: すべてのコアテストが成功している

#### Phase 4: Integration

```
1. モジュール間連携のテストを先に書く
2. 統合テストを実行して Red を確認
3. 連携部分を実装して Green にする
4. tasks.md にチェック [x] を入れる
```

**完了条件**: 統合テストが成功している

#### Phase 5: Polish

```
1. コードの重複を削除（DRY原則）
2. 命名を改善
3. ドキュメントコメントを追加
4. パフォーマンスの最適化
5. tasks.md にチェック [x] を入れる
```

**完了条件**: すべてのテストが成功し、コード品質が基準を満たしている

## 処理フロー

### 1. 実装前検証

**ドキュメントの読み込みと検証**:

```
1. タスク分解を読み込み: .sdd/task/{チケット番号}/tasks.md
2. 設計書を読み込み: .sdd/specification/[{path}/]{機能名}_design.md
3. 抽象仕様書を読み込み: .sdd/specification/[{path}/]{機能名}_spec.md
4. PRDを読み込み（存在する場合）: .sdd/requirement/[{path}/]{機能名}.md
```

**⚠️ 命名規則の違いに注意**:

- **requirement配下**: サフィックスなし（`index.md`, `{機能名}.md`）
- **specification配下**: `_spec` または `_design` サフィックスが必須（`index_spec.md`, `{機能名}_spec.md`）

**タスク完了率の確認**:

````markdown
## タスク進捗分析

| フェーズ                 | 総タスク数  | 完了    | 残り     | 完了率    |
|:---------------------|:-------|:------|:-------|:-------|
| Phase 1: Foundation  | 3      | 0     | 3      | 0%     |
| Phase 2: Core        | 5      | 0     | 5      | 0%     |
| Phase 3: Integration | 2      | 0     | 2      | 0%     |
| Phase 4: Testing     | 4      | 0     | 4      | 0%     |
| Phase 5: Finishing   | 2      | 0     | 2      | 0%     |
| **合計**               | **16** | **0** | **16** | **0%** |

### 現在のステータス

- Phase 1: Foundation の開始準備完了
````

### 2. 実装フェーズ

TDD原則に従って順番にタスクを実行:

#### フェーズ実行順序

```
Phase 1: Foundation（セットアップ）
   ↓
Phase 2: Core（TDDループ）
   ↓
Phase 3: Integration（統合）
   ↓
Phase 4: Testing（テスト）
   ↓
Phase 5: Finishing（仕上げ）

```

#### Phase 1: Foundation（基盤）

**目的**: プロジェクト構造と依存関係の確立

**タスク**:

- ディレクトリ構造の作成
- 型定義
- 依存関係のインストール
- 設定ファイル

**TDDアプローチ**:

- テストインフラを最初にセットアップ
- テストランナーが動作することを確認
- まだプロダクションコードは書かない

**自動進捗追跡**:

````markdown
### Phase 1: Foundation

| #   | タスク          | 説明            | 完了条件       | ステータス |
|:----|:-------------|:--------------|:-----------|:------|
| 1.1 | ディレクトリセットアップ | モジュール構造を作成    | ディレクトリが存在  | [x]   |
| 1.2 | 型定義          | コア型を定義        | 型がコンパイルされる | [x]   |
| 1.3 | テストセットアップ    | テストフレームワークを設定 | テストが実行可能   | [x]   |
````

#### Phase 2: Core（TDDループ）

**目的**: 主要なビジネスロジックの実装

**各タスクのTDDサイクル**:

```
1. RED: 失敗するテストを書く
   - 期待される動作を定義
   - テストは失敗するはず（実装がないため）
   - コミット: "test: add test for {機能}"

2. GREEN: テストを通す
   - テストが通る最小限のコードを書く
   - テストが成功することを確認
   - コミット: "feat: implement {機能}"

3. REFACTOR: コードをクリーンアップ
   - 動作を変えずに構造を改善
   - すべてのテストが依然として通ることを確認
   - コミット: "refactor: clean up {機能}"
```

**自動進捗追跡**:

````markdown
### Phase 2: Core実装

| #   | タスク      | 説明        | 完了条件  | ステータス |
|:----|:---------|:----------|:------|:------|
| 2.1 | ユーザー検証   | ユーザー入力を検証 | テスト合格 | [x]   |
| 2.2 | データ永続化   | データベースに保存 | テスト合格 | [ ]   |
| 2.3 | ビジネスロジック | コア機能ロジック  | テスト合格 | [ ]   |

### Phase 3: Integration（統合）

**目的**: コンポーネントを接続

**タスク**:

- サービスレイヤー統合
- APIエンドポイント配線
- イベントハンドリング
- ミドルウェア統合

**検証**:

- 統合テストが合格
- エンドツーエンドフローが動作
- 仕様準拠を確認

### Phase 4: Testing（テスト）

**目的**: 包括的なテストカバレッジ

**テストタイプ**:

| テストタイプ        | 目的             | カバレッジ対象      |
|:--------------|:---------------|:-------------|
| **ユニットテスト**   | コンポーネント個別の動作   | コアビジネスロジック   |
| **統合テスト**     | コンポーネント間の相互作用  | サービスレイヤー、API |
| **エッジケーステスト** | 境界条件           | エラーパス、制限     |
| **非機能テスト**    | パフォーマンス、セキュリティ | NFR検証        |

**自動検証**:

- テストスイートを実行
- カバレッジメトリクスをチェック
- すべての受入基準が満たされていることを確認

### Phase 5: Finishing（仕上げ）

**目的**: 最終的な改善

**タスク**:

- コードクリーンアップ
- ドキュメント更新
- パフォーマンス最適化
- 設計書の更新
````

### 3. 継続的な検証

各タスク完了後:

**自動チェック**:

```
1. 関連するテストを実行 → 合格必須
   ↓
2. 仕様との整合性をチェック → 一致必須
   ↓
3. tasks.md を更新 → [x] をマーク
   ↓
4. 明確なメッセージでコミット
```

**仕様整合性チェック**（自動）:

````markdown
### 仕様整合性チェック

| 検証項目 | ステータス | 備考 |
|:---|:---|:---|
| APIシグネチャが仕様と一致 | ✓ | すべての公開APIを実装 |
| データモデルが仕様と一致 | ✓ | 型が仕様と整合 |
| 動作がシーケンス図と一致 | ✓ | フローを検証 |
| 非機能要件を満たす | ⚠ | レスポンス時間の調整が必要 |
````

### 4. 進捗追跡

**tasks.md の自動進捗更新**:

```diff
### Phase 2: Core実装

| # | タスク | 説明 | 完了条件 | ステータス |
|:---|:---|:---|:---|:---|
- | 2.1 | ユーザー検証 | ユーザー入力を検証 | [ ] |
+ | 2.1 | ユーザー検証 | ユーザー入力を検証 | [x] |
```

**進捗ログ** `.sdd/task/{チケット番号}/implementation_progress.md`:

````markdown
# 実装進捗ログ

## 2024-01-15 14:30 - タスク 2.1 完了

**タスク**: ユーザー検証
**アプローチ**: スキーマ検証にZodを使用
**テスト**: 8件のテストを追加、すべて合格
**コミット**:

- test: add user validation tests (abc123)
- feat: implement user validation (def456)

**備考**: TypeScript統合の向上のため、JoiではなくZodを採用
````

### 5. 完了検証

すべてのタスクが完了したとき:

**最終検証チェックリスト**:

````markdown
## 実装完了検証

### タスク完了

- [x] すべてのPhase 1タスクが完了 (3/3)
- [x] すべてのPhase 2タスクが完了 (5/5)
- [x] すべてのPhase 3タスクが完了 (2/2)
- [x] すべてのPhase 4タスクが完了 (4/4)
- [x] すべてのPhase 5タスクが完了 (2/2)

### テスト検証

- [x] すべてのテストが合格
- [x] コードカバレッジ ≥ 80%
- [x] エッジケースをカバー
- [x] 非機能要件をテスト

### 仕様整合性

- [x] すべての仕様APIを実装
- [x] データモデルが仕様と一致
- [x] 動作が仕様と整合
- [x] 設計書を判断事項で更新

### ドキュメント

- [x] コードコメントを追加
- [x] 設計書を更新
- [x] 実装ログが完成
- [x] 破壊的変更をドキュメント化（ある場合）

### レビュー準備完了

✓ すべてのチェックに合格 - PR作成の準備完了

```

### 6. 開始フェーズの決定

```

- Phase 1 のタスクがすべて完了 → Phase 2 から開始
- Phase 2 のタスクがすべて完了 → Phase 3 から開始
- 以下同様...

```

**--phase オプション指定時**: 指定されたフェーズから強制的に開始

### 7. フェーズごとの実行

```

For each phase:

1. 該当フェーズのタスクリストを表示
2. 各タスクを順番に実行
   a. タスクの詳細を確認
   b. 設計書・仕様書を参照して実装
   c. TDDアプローチに従う
   d. 完了後、tasks.md にチェック [x] を入れる
3. フェーズ完了後、テストを実行
4. すべてのテストが成功したら次のフェーズへ
````

## 出力フォーマット

### フェーズ開始時

````markdown
# 実装: {機能名}

## Phase {n}: {フェーズ名}

### このフェーズのタスク

1. **タスク {n.m}: {タスク名}**
    - 説明: {タスクの説明}
    - 完了条件: {条件}
    - 依存関係: {依存タスク}

### TDDアプローチ

**REDフェーズ**: {最初に書くテスト}
**GREENフェーズ**: {必要な最小限の実装}
**REFACTORフェーズ**: {クリーンアップの機会}

### 実装を開始しています...
````

### タスク完了時

````markdown
## ✓ タスク {n.m} 完了: {タスク名}

### 実装サマリー

- アプローチ: {簡潔な説明}
- 変更ファイル: {ファイルリスト}
- 追加テスト: {テスト数}
- テスト結果: {合格/失敗状態}

### コミット

- {commit-hash}: {commit-message}

### 仕様整合性

- [x] API仕様と一致
- [x] データモデルと一致
- [x] 設計判断に従う

### 進捗更新

- Phase {n} 進捗: {完了}/{総数} タスク ({パーセント}%)
- 全体進捗: {完了}/{総数} タスク ({パーセント}%)

### 次のタスク

タスク {n.m+1}: {次のタスク名} に移行
````

### フェーズ完了時

````markdown
## ✓ Phase {n} 完了: {フェーズ名}

### フェーズサマリー

- 完了タスク: {n} タスク
- 追加テスト: {n} テスト
- コミット: {n} コミット
- 所要時間: {時間推定}

### 主な成果

- {成果 1}
- {成果 2}

### 設計判断

- {判断 1}: {根拠}
- {判断 2}: {根拠}

### 次のフェーズ

Phase {n+1}: {フェーズ名} を開始する準備完了
````

### 実装完了時

````markdown
# ✓ 実装完了: {機能名}

## サマリー

| メトリクス | 値 |
|:---|:---|
| 総タスク数 | {n} |
| 完了タスク | {n} |
| 追加テスト | {n} |
| テスト合格率 | 100% |
| コードカバレッジ | {パーセント}% |
| コミット数 | {n} |

## フェーズ内訳

| フェーズ | タスク | ステータス |
|:---|:---|:---|
| Phase 1: Foundation | {n}/{n} | ✓ 完了 |
| Phase 2: Core | {n}/{n} | ✓ 完了 |
| Phase 3: Integration | {n}/{n} | ✓ 完了 |
| Phase 4: Testing | {n}/{n} | ✓ 完了 |
| Phase 5: Finishing | {n}/{n} | ✓ 完了 |

## 仕様整合性

✓ すべての検証チェックに合格

## 設計判断のドキュメント化

主要な判断を `.sdd/specification/[{path}/]{機能名}_design.md` に統合しました

## 次のステップ

1. 実装ログを確認: `.sdd/task/{チケット番号}/implementation_progress.md`
2. 最終仕様チェックを実行: `/check_spec {機能名}`
3. タスクディレクトリをクリーンアップ: `/task_cleanup {チケット番号}`
4. PRを作成: 標準PRワークフローを使用

````

## 実装オプション

### Continueモード

中断された実装を再開:

```
/implement user-auth TICKET-123 --continue
```

動作:

- tasks.md から進捗を読み込み
- 最初の未完了タスクから再開
- 実装ログを保持

### フェーズスキップモード

特定のフェーズにスキップ（注意して使用）:

```
/implement user-auth TICKET-123 --start-from phase-3
```

要件:

- 前のフェーズがすべて完了としてマーク済み
- 設計書が存在
- 前のフェーズのテストが合格

### ドライランモード

変更を加えずに実装をシミュレート:

```
/implement user-auth TICKET-123 --dry-run
```

表示内容:

- 実装計画
- タスク実行順序
- 推定複雑度

## ベストプラクティス

### コミット戦略

このコミットパターンに従ってください:

| フェーズ     | コミットプレフィックス | 例                                    |
|:---------|:------------|:-------------------------------------|
| セットアップ   | `chore`     | `chore: setup test infrastructure`   |
| テスト      | `test`      | `test: add user validation tests`    |
| 実装       | `feat`      | `feat: implement user validation`    |
| リファクタリング | `refactor`  | `refactor: extract validation logic` |
| 修正       | `fix`       | `fix: handle null user status`       |
| ドキュメント   | `docs`      | `docs: update design decisions`      |

### 一時停止すべきタイミング

以下の場合は停止して明確化を求めてください:

- 仕様が曖昧（`/clarify` を使用）
- 複数の有効な解釈が存在
- 非機能要件が不明確
- 外部依存関係が利用不可

### 他のコマンドとの統合

```
事前: /clarify → /task_breakdown → /implement
実行中: /implement（継続的な /check_spec）
事後: /implement → /check_spec → /task_cleanup → PR
```

## 実装ログの記録

実装中の判断や問題を `.sdd/task/{チケット番号}/implementation_log.md` に自動記録：

### ログ項目

| 項目         | 記録内容            |
|:-----------|:----------------|
| **実装判断**   | 設計書に記載のない実装上の判断 |
| **問題と解決策** | 遭遇した問題とその解決方法   |
| **代替案の検討** | 採用しなかった代替案とその理由 |
| **技術的発見**  | 実装中に得られた知見      |
| **テスト結果**  | テスト実行結果の記録      |

### ログの活用

実装完了後、重要な内容を `*_design.md` に統合します（`/task_cleanup` で実行）。

## TDDベストプラクティス

### Red-Green-Refactor サイクル

```
1. Red（失敗するテストを書く）
   ↓
2. Green（最小限の実装でテストを通す）
   ↓
3. Refactor（テストを維持しながらコード改善）
   ↓
   繰り返し
```

### テストファーストの原則

| 原則              | 詳細                |
|:----------------|:------------------|
| **テストを先に書く**    | 実装前にテストケースを作成     |
| **小さなステップ**     | 一度に1つの機能だけを実装     |
| **最小限の実装**      | テストが通る最小限のコードを書く  |
| **継続的リファクタリング** | テストを維持しながら常にコード改善 |

### テストカバレッジ目標

| 対象         | カバレッジ目標 |
|:-----------|:--------|
| **コア機能**   | 90%以上   |
| **統合部分**   | 80%以上   |
| **エッジケース** | 100%    |

## エラーハンドリング

### テスト失敗

````markdown
⚠ タスク {n.m} テスト失敗

**テスト失敗数**: {n} テスト失敗

**必要なアクション**:

1. テスト失敗を確認
2. 実装を修正 または
3. 仕様理解が間違っていた場合はテストを更新

**テストが合格するまでタスクを完了としてマークしない**
````

### 仕様不整合の検出

````markdown
⚠ 仕様不整合を検出

**問題**: 実装が仕様と一致しません

**詳細**:

- 仕様の記述: {仕様要件}
- 実装内容: {実施内容}

**必要なアクション**:

1. 仕様に合わせて実装を更新 または
2. 要件が変更された場合は仕様を更新
3. 検証を再実行

**タスクは未完了のまま**
````

## 注意事項

- 常にTDDアプローチに従う: Red → Green → Refactor
- テストをスキップして「時間を節約」しない
- テストが合格し、仕様と整合している場合のみタスクを完了とマークする
- 実装後ではなく、実装中に設計判断をドキュメント化する
- 明確なメッセージで頻繁にコミットする
- 知識移転のために実装ログを更新し続ける
- フェーズ境界で `/check_spec` を実行して、ドリフトを早期検出する
