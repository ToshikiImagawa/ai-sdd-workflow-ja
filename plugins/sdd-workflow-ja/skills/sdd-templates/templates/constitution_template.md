# プロジェクト原則

**バージョン**: 1.0.0
**最終更新日**: YYYY-MM-DD
**ステータス**: 有効

## 目的

このドキュメントは、プロジェクト開発を統制する非交渉原則と基準を定義します。すべてのコード、仕様、設計判断はこれらの原則に従う必要があります。

## 原則階層

```
1. ビジネス原則（最優先）
   ↓
2. アーキテクチャ原則
   ↓
3. 開発手法原則
   ↓
4. 技術制約
```

優先度が高い原則が低い原則に優先します。

---

## 1. ビジネス原則（最優先）

### B-001: {原則名}

**原則**: {原則の説明}

**適用範囲**: {適用範囲}

**検証方法**:

- [ ] {検証項目1}
- [ ] {検証項目2}
- [ ] {検証項目3}

**違反例**:

- {違反例1}
- {違反例2}

**準拠例**:

- {準拠例1}
- {準拠例2}

---

### B-002: {原則名}

**原則**: {原則の説明}

**適用範囲**: {適用範囲}

**検証方法**:

- [ ] {検証項目1}
- [ ] {検証項目2}

---

## 2. アーキテクチャ原則

### A-001: Library-First

**原則**: 可能な限り既存ライブラリを活用し、車輪の再発明を避ける

**適用範囲**: すべての実装

**検証方法**:

- [ ] 新規実装前に既存ライブラリを調査したか
- [ ] 自作する場合の明確な理由があるか

**違反例**:

- ライブラリ調査なしで自作実装
- よく知られた問題（暗号化、認証等）を独自実装

**準拠例**:

- 既存ライブラリを調査し、適切なものを選定
- 自作する場合は理由を設計書に明記（パフォーマンス、依存削減等）

---

### A-002: Clean Architecture

**原則**: レイヤー分離を徹底し、依存方向を外側から内側へ単方向にする

**適用範囲**: すべてのモジュール設計

**検証方法**:

- [ ] Presentation → Application → Domain → Infrastructure の依存方向が守られている
- [ ] 内側のレイヤーが外側のレイヤーに依存していない
- [ ] ドメインロジックがインフラに依存していない

**違反例**:

- ドメインロジックが直接データベースアクセス層を参照
- ビジネスロジックにフレームワーク固有のコードが混在

**準拠例**:

- 依存性逆転原則（DIP）を使用したレイヤー分離
- インターフェースを介した疎結合設計

---

## 3. 開発手法原則

### D-001: Test-First

**原則**: テストを先に書いてから実装する（TDD）

**適用範囲**: すべてのコア機能

**検証方法**:

- [ ] 実装前にテストケースが作成されている
- [ ] テストカバレッジ > 80%
- [ ] 失敗するテストを先に書き、実装で通すフローを遵守

**違反例**:

- 実装完了後にテストを追加
- テストなしでのマージ

**準拠例**:

- Red → Green → Refactor のサイクルを遵守
- テストケース作成 → 実装 → リファクタリング

---

### D-002: Specification-Driven

**原則**: 仕様書なしで実装しない

**適用範囲**: すべての新機能・変更

**検証方法**:

- [ ] `*_spec.md` が存在する
- [ ] `*_design.md` が存在する
- [ ] 仕様書が最新（実装前に更新されている）

**違反例**:

- 口頭指示のみで実装開始
- 仕様書が古いまま実装

**準拠例**:

- Specify → Plan → Tasks → Implement のフローを遵守
- 仕様書を真実の源（Single Source of Truth）として管理

---

## 開発標準

### コード品質

| 標準          | 要件            | ツール                    | 適用方法            |
|:------------|:--------------|:-----------------------|:----------------|
| **Linting** | エラー・警告ゼロ      | ESLint/Prettier        | Pre-commit hook |
| **型安全性**    | 厳密な型チェック      | TypeScript strict mode | CI/CD           |
| **複雑度**     | 循環的複雑度 ≤ 10   | SonarQube              | Code review     |
| **重複**      | 3回以上のブロック重複禁止 | CodeClimate            | CI/CD gate      |

### ドキュメント

| 標準         | 要件                        | 配置場所                  | 更新頻度   |
|:-----------|:--------------------------|:----------------------|:-------|
| **仕様書**    | すべての機能に `*_spec.md` が必要   | `.sdd/specification/` | 実装前    |
| **設計書**    | すべての実装に `*_design.md` が必要 | `.sdd/specification/` | 設計フェーズ |
| **API文書**  | すべての公開APIをドキュメント化         | ソースファイル内              | コード変更時 |
| **README** | 最新のセットアップ手順               | プロジェクトルート             | 必要に応じて |

### テスト

| 標準             | 要件             | 適用方法          | 例外              |
|:---------------|:---------------|:--------------|:----------------|
| **ユニットカバレッジ**  | ≥80% 行カバレッジ    | CI/CD gate    | UIコンポーネント (60%) |
| **結合テスト**      | すべてのメインフローをカバー | Manual review | -               |
| **エッジケース**     | 境界条件をテスト       | Code review   | -               |
| **パフォーマンステスト** | NFR要件を満たす応答時間  | 自動ベンチマーク      | -               |

### セキュリティ

| 標準           | 要件              | 適用方法                | レビュー頻度 |
|:-------------|:----------------|:--------------------|:-------|
| **入力検証**     | すべてのユーザー入力を検証   | Security review     | 各PR    |
| **認証**       | 業界標準の手法のみ       | Architecture review | 設計フェーズ |
| **シークレット管理** | コードにシークレットを含めない | Pre-commit hooks    | 各コミット  |
| **依存関係スキャン** | 重大な脆弱性ゼロ        | CI/CD gate          | 毎日     |

## アーキテクチャ制約

### レイヤードアーキテクチャ

```
プレゼンテーション層
      ↓
ビジネスロジック層
      ↓
データアクセス層
      ↓
データベース
```

**ルール**:

- レイヤーをスキップしてはならない
- 循環依存禁止
- 依存方向は常に下向き
- 各レイヤーは単一責任

### 技術スタック制約

| レイヤー        | 許可される技術                      | 禁止事項             | 理由            |
|:------------|:-----------------------------|:-----------------|:--------------|
| **フロントエンド** | React, TypeScript            | jQuery, plain JS | 型安全性、モダンなパターン |
| **バックエンド**  | Node.js, Express, TypeScript | 型なしJavaScript    | 一貫性、安全性       |
| **データベース**  | PostgreSQL                   | MongoDB          | リレーショナルデータモデル |
| **テスト**     | Jest, Testing Library        | Enzyme           | アクティブメンテナンス   |

**例外プロセス**: RFCでチーム承認を得て変更を提案

### モジュール構成

```
src/
├── domain/           # ビジネスロジック（純粋、依存なし）
├── application/      # ユースケース、オーケストレーション
├── infrastructure/   # 外部統合
└── presentation/     # API、UI
```

**依存ルール**:

- `domain/` は何にも依存しない
- `application/` は `domain/` に依存
- `infrastructure/` は `domain/` と `application/` に依存
- `presentation/` はすべてのレイヤーに依存

## 意思決定フレームワーク

技術的トレードオフに直面した場合、以下の順序で優先順位付けします：

1. **正確性** - 仕様を満たしているか？
2. **セキュリティ** - 安全か？
3. **シンプルさ** - 最もシンプルな解決策か？
4. **パフォーマンス** - 十分に高速か？
5. **保守性** - 保守可能か？
6. **開発者体験** - 作業しやすいか？

**タイブレーカー**: 後で変更しやすい方を選択

## 品質ゲート

### Pre-Commit

- [ ] Linterが通る
- [ ] シークレットが検出されない
- [ ] ローカルでテストが通る

### Pre-PR

- [ ] すべてのテストが通る
- [ ] カバレッジ ≥ 80%
- [ ] 仕様整合性を確認（`/check_spec`）
- [ ] 設計書を更新

### Pre-Merge

- [ ] コードレビュー承認（2名のレビュアー）
- [ ] CI/CDパイプラインが成功
- [ ] マージコンフリクトなし
- [ ] ドキュメント更新

### Pre-Release

- [ ] QAサインオフ
- [ ] パフォーマンスベンチマーク合格
- [ ] セキュリティスキャン合格
- [ ] デプロイメントプランレビュー

## 4. 技術制約

### T-001: {プログラミング言語の制約}

**原則**: {言語固有の制約}

**適用範囲**: すべてのソースコード

**検証方法**:

- [ ] {検証項目1}
- [ ] {検証項目2}

**違反例**:

- {違反例}

**準拠例**:

- {準拠例}

---

### T-002: No Runtime Errors

**原則**: 実行時エラーを許容しない（コンパイル時に検出）

**適用範囲**: すべてのコード

**検証方法**:

- [ ] strict モード有効（TypeScript等）
- [ ] 型ガードの適切な使用
- [ ] Error Boundary の実装（フロントエンド）
- [ ] エラーハンドリングが網羅的

**違反例**:

- any 型の多用
- try-catch のない非同期処理
- 未処理の Promise rejection

**準拠例**:

- すべての関数に明確な型定義
- エラーケースの網羅的なハンドリング
- Result型・Option型の活用

---

### T-003: {セキュリティ制約}

**原則**: {セキュリティに関する制約}

**適用範囲**: {適用範囲}

**検証方法**:

- [ ] {検証項目1}
- [ ] {検証項目2}

---

## 原則追加のガイドライン

新しい原則を追加する際は、以下を考慮してください：

### 良い原則の条件

| 条件        | 説明                         |
|:----------|:---------------------------|
| **検証可能**  | チェックリストで検証できること            |
| **明確**    | 曖昧さがなく、準拠/違反の判断が明確であること    |
| **正当化可能** | なぜその原則が必要かが説明できること         |
| **実現可能**  | チーム全体が実践できること              |
| **永続的**   | 一時的な方針ではなく、長期的に守るべき原則であること |

### 追加プロセス

```
1. 提案（Issue等で議論）
   ↓
2. チーム承認
   ↓
3. 原則ファイルに追加
   ↓
4. バージョンをマイナーアップ（例: 1.0.0 → 1.1.0）
   ↓
5. 影響を受けるドキュメントを更新
   ↓
6. /constitution validate で検証
```

## コンプライアンス

### 適用メカニズム

**自動化**:

- Pre-commitフック（フォーマット、シークレット）
- CI/CDパイプライン（テスト、カバレッジ、セキュリティ）
- 依存関係スキャン（脆弱性）

**手動**:

- コードレビュー（アーキテクチャ、設計判断）
- 設計レビュー（原則への準拠）
- 定期監査（四半期ごと）

### 違反への対処

| 重大度    | 対応                 | 例                  |
|:-------|:-------------------|:-------------------|
| **重大** | 即座にマージをブロック        | テストなし、セキュリティスキャン失敗 |
| **主要** | 明示的な正当化が必要         | ADRなしのカスタム実装       |
| **軽微** | 現在のPRまたはフォローアップで修正 | 軽微なドキュメント更新        |

### 例外プロセス

原則の遵守が不可能な場合：

1. **文書化**: アーキテクチャ決定記録（ADR）を作成
2. **正当化**: なぜ原則に従えないか説明
3. **緩和**: 補償統制を説明
4. **レビュー**: テックリード + 2名のレビュアーから承認を得る
5. **追跡**: 技術的負債ログに追加
6. **計画**: 解決のタイムラインを設定（一時的な場合）

### 監査証跡

すべての例外と違反は以下の目的でログに記録されます：

- パターン識別
- 原則の改善
- コンプライアンスメトリクス
- チームレトロスペクティブ

## メトリクスとモニタリング

以下を通じてコンプライアンスを追跡：

| メトリクス         | 目標     | 測定方法                     |
|:--------------|:-------|:-------------------------|
| **仕様カバレッジ**   | 100%   | `/constitution validate` |
| **テストカバレッジ**  | ≥80%   | CI/CDレポート                |
| **コード品質**     | Aグレード  | SonarQube                |
| **セキュリティスコア** | 重大/高 0 | 依存関係スキャン                 |
| **原則バージョン**   | PRに記載  | 手動                       |

チームレトロスペクティブで月次レビュー。

## 導入

### 新しいチームメンバー向け

1. この原則を読む（必須、初日）
2. アーキテクチャ決定記録をレビュー
3. トレーニング演習を完了
4. 経験豊富な開発者をシャドウイング
5. 最初のPRは原則チャンピオンがレビュー

### 既存コード向け

**移行戦略**:

- 新規コード: 完全準拠が必要
- 変更コード: ファイルの30%以上に触れる場合は準拠させる
- レガシーコード: 大規模なリファクタリングでない限り準拠不要

**タイムライン**: 6ヶ月以内に80%の準拠を目指す

## 連絡先

- **原則チャンピオン**: [名前/役割をリスト]
- **質問**: [Slackチャンネル/メール]
- **変更提案**: [RFCプロセスリンク]

## 変更履歴

### v1.0.0 (YYYY-MM-DD)

**初版原則の確立**

- コア原則を定義（P1-P3）
- 開発標準を設定
- アーキテクチャ制約を確立
- 意思決定フレームワークを作成
- B-001, B-002: ビジネス原則を定義
- A-001, A-002: アーキテクチャ原則を定義
- D-001, D-002: 開発手法原則を定義
- T-001, T-002, T-003: 技術制約を定義

---

## 改定プロセス

### マイナーバージョン (x.Y.z)

**対象範囲**: 明確化、追加の例、適用方法の更新

**プロセス**:

1. PRで変更を提案
2. チームディスカッション（非同期、3営業日）
3. チームの50%の承認
4. バージョン更新
5. チームミーティングで変更を周知

**タイムライン**: 約1週間

### メジャーバージョン (X.y.z)

**対象範囲**: 新しい原則、既存原則の変更、原則の削除

**プロセス**:

1. RFC（Request for Comments）ドキュメントを作成
2. チーム全体でのディスカッション（最低1週間）
3. チームミーティングでプレゼンテーション
4. 投票（チームの75%の承認が必要）
5. バージョン更新
6. 影響を受けるコードの移行ガイドを作成
7. チームトレーニングセッションを予定
8. 2週間のコンプライアンス監視

**タイムライン**: 約1ヶ月

---

## 関連ドキュメント

### この原則を参照すべきドキュメント

| ドキュメント                           | 参照方法                |
|:---------------------------------|:--------------------|
| `.sdd/SPECIFICATION_TEMPLATE.md` | 原則への言及セクションを含める     |
| `.sdd/DESIGN_DOC_TEMPLATE.md`    | 原則準拠のチェックリストを含める    |
| `*_spec.md`                      | 原則に基づいた設計を記述        |
| `*_design.md`                    | 設計判断が原則に準拠していることを明記 |

### 原則準拠の検証

```bash
/constitution validate
```

このコマンドで、すべての仕様書・設計書が原則に従っているかを自動検証できます。

---

## セマンティックバージョニング

原則のバージョンは以下のルールに従います：

| バージョン種別 | 用途                  | 例             |
|:--------|:--------------------|:--------------|
| Major   | 既存原則の削除・大幅変更（破壊的変更） | 1.0.0 → 2.0.0 |
| Minor   | 新しい原則の追加            | 1.0.0 → 1.1.0 |
| Patch   | 原則の表現修正、誤字修正        | 1.0.0 → 1.0.1 |

---

*この原則は生きたドキュメントです。チームの学びとプロジェクトのニーズに応じて進化すべきものです。*
